#--------------------------collaboration tool -----------------------------------------

features -- 


- custom link to share 
    - need a rate limiter for too many requests
    - create a link and share 
    - name login can use ( previous services )

- video call one on one like zoom or meet 
    - voice 
    - video
    - real-time 
    - video bitrate adjust as per network 

- drawing board 
    - drawing board 
    - one two one collaboration 
    - typing support as well 
    - shapes as well (later)
    - mulipage suppport
    - this as inspiration - https://webwhiteboard.com/

- code editor
    - write code in real time 
    - both party can write code and edit at the same time
    - run with the compiler if needed (later)

- chat feature
    - send one to one message 

- Auto adjust of the UI 
    - Adjust the video if drawing is open 
    - Adjust the video if text is open 

- can't support for the mobile right now (too small screen) 
    - need to have a limiter for screen size

- tabbing support for the window
    - resize the tab on addition 
    - video resize
    
- meeting end support 
    - re-login using cookie
    - cancel the meeting 
    - kill the link (like kill chat)






Technologies needed -- 

Building an online collaboration tool with features like video/audio meetings, real-time text editing, a jam board, and a chat system is a complex yet highly feasible project. Since you already have a backend running on Flask, I’ll focus on integrating technologies that complement Flask while delivering real-time features. Below are the tools and technologies to help you build this system:
1. WebSockets for Real-Time Communication

    Why WebSockets?: For features like real-time chat, video/audio calls, and collaborative editing, WebSockets are ideal since they allow bi-directional, low-latency communication between client and server.
    Tool:
        Flask-SocketIO: This extension enables WebSocket communication for real-time events using Flask. It can handle messaging for chat, real-time text editing, and even audio/video signaling.
        Alternatives: If you outgrow Flask-SocketIO, you can shift to Django Channels or FastAPI with WebSocket support for more scalable applications.

2. Video/Audio Conferencing

    WebRTC: For peer-to-peer video and audio meetings, WebRTC is the go-to standard. It supports real-time communication directly between browsers without the need for plugins.
        Use PeerJS or Simple-Peer libraries to simplify the WebRTC implementation.
        Integrate TURN/STUN servers: You'll need these servers to help in WebRTC connection establishment, especially for users behind firewalls.
        Signaling server: Use Flask-SocketIO to serve as the signaling mechanism for initiating and managing WebRTC sessions.

Flow:

    Client-side: WebRTC API to establish peer-to-peer connections.
    Backend: Flask-SocketIO for signaling (handling session initiation, call requests, etc.).

3. Real-Time Text Editor (Collaborative Editing)

    Operational Transformation (OT) or CRDT (Conflict-free Replicated Data Types): These algorithms help in managing concurrent edits from multiple users in real-time. This is essential for a shared editor like Google Docs.
        Tool: Use ShareDB or Yjs for OT or CRDT. These libraries can handle collaborative text editing with real-time synchronization.
        Integration:
            Frontend: Use a rich-text editor like Quill or CodeMirror.
            Backend: Use Flask-SocketIO to synchronize content changes between users in real time.

4. Jam Board (Real-Time Collaborative Drawing)

    Canvas API: For drawing and collaboration in real time, HTML5’s Canvas API is ideal for building a whiteboard-like feature.
        Fabric.js: A JavaScript library that simplifies working with the HTML5 Canvas element and enables collaboration for drawing.
        Integration: Use Flask-SocketIO to broadcast drawing events to all connected users. Every user’s drawing action (e.g., lines, shapes) can be broadcast in real time.

5. Chat System

    Flask-SocketIO: You can extend Flask-SocketIO to handle the real-time chat system. It will broadcast messages in real time between users or groups.
    Redis Pub/Sub: If scaling to a large number of users, use Redis for a publish-subscribe messaging model. Redis can act as a message broker, managing chat communications across distributed instances.
    Frontend: Build a chat interface with React.js or Vue.js, which can easily handle dynamic updates from WebSockets.

6. Backend (Flask)

    Since you're already using Flask, here’s how it fits into the architecture:
        REST API: Serve the necessary endpoints for user authentication, session management, document access, etc.
        WebSockets: Use Flask-SocketIO for handling real-time connections (chat, video call signaling, real-time editor updates, and jam board events).
        Session Management: Implement secure user authentication using Flask-Login or Flask-JWT for token-based authentication.
        Scaling: You can horizontally scale Flask with a message queue system like Redis and tools like Celery for task scheduling, especially for handling background processes (e.g., sending notifications or handling media uploads).

7. Frontend (User Interface)

    React.js or Vue.js: Both are excellent choices for building dynamic and responsive UIs that handle real-time updates well. Use components for the following:
        Video/audio call interface
        Real-time text editor and jam board
        Chat system
    Component Libraries: Use libraries like Ant Design or Material-UI to accelerate UI development.
    State Management: For managing the application state (like active users, shared documents, ongoing calls), use Redux or Vuex.

8. Database

    MongoDB: Since Flask integrates well with MongoDB (via Flask-PyMongo or Flask-MongoEngine), this NoSQL database is a good choice for handling real-time data. You can store:
        User profiles
        Chat messages
        Session history (for video/audio calls)
        Documents for the text editor
    PostgreSQL (optional): If you need a relational database for transactional data, you can use PostgreSQL alongside MongoDB.

9. Deployment

    Docker: Use Docker to containerize your Flask backend, WebSocket server, and other microservices (if applicable).
    Kubernetes: For orchestrating and scaling multiple microservices (backend, WebSocket server, Redis, etc.), use Kubernetes to manage deployment in production.
    Nginx: Nginx can serve as the reverse proxy for your Flask backend, handling requests and improving security by terminating SSL (HTTPS).
    SSL/TLS: Use Let’s Encrypt with Certbot to secure communication for all real-time interactions (video, chat, etc.).

10. Authentication & Security

    OAuth2/OpenID: Allow users to log in with services like Google, GitHub, etc., using OAuth2.
    JWT (JSON Web Tokens): Use JWT for handling secure session authentication for both REST API and WebSocket connections.
    Security for WebRTC: Use DTLS/SRTP encryption for video/audio calls. WebRTC supports encryption by default, but ensure your signaling server is secure.

11. Scalability & Performance

    Redis: Use Redis for session management and pub/sub for chat or notifications.
    Load Balancing: Use a load balancer (e.g., AWS ELB or Nginx) to distribute traffic across multiple Flask instances.
    CDN: Use a content delivery network (e.g., Cloudflare) for faster loading of static assets.

Tech Stack Summary:

    Backend: Flask, Flask-SocketIO
    Frontend: React.js/Vue.js, WebRTC, Fabric.js (for Jam board)
    Real-Time Communication: WebRTC, Flask-SocketIO, Redis
    Collaboration Logic: ShareDB/Yjs for collaborative text editing
    Database: MongoDB for real-time data, Redis for pub/sub messaging
    Deployment: Docker, Kubernetes, Nginx
    Authentication: OAuth2, JWT


The system is divided into several distinct components, each responsible for specific functionality. The architecture follows a microservices-based design for scalability, maintainability, and independent deployments. Components communicate via WebSockets, HTTP APIs, and message queues.
Key Components

    Client-Side (Frontend)
        Web App: React.js or Vue.js
        WebRTC for real-time video/audio
        Collaborative editors and drawing canvas for real-time jam board
        WebSockets for real-time communication (chat, document editing, etc.)

    Backend Services (Microservices)
        WebSocket Server: Manages real-time communication for chat, video call signaling, document editing, etc.
        Collaboration Service: Handles real-time synchronization of documents (text editor) and jam board.
        Video/Audio Service: Manages WebRTC signaling for video/audio connections (via signaling server).
        Authentication Service: Manages user authentication, OAuth2 (e.g., Google, GitHub logins), and session management.
        API Gateway: Routes client requests to the appropriate microservices and handles authentication.
        Database Service: Manages user data, session history, chat messages, and document storage.
        Media Service: Stores user-uploaded media (images, documents, etc.) and serves it via a CDN.

    Infrastructure
        Redis: Handles pub/sub messaging for real-time features (chat, video call signaling, etc.) and session management.
        MongoDB: Stores collaborative documents, chat history, and user profiles.
        File Storage (S3, etc.): For storing media files like images, videos, and other shared resources.
        Load Balancer: Distributes incoming traffic among backend services.
        CDN (Content Delivery Network): Accelerates the delivery of static content (images, files).

    DevOps/Orchestration
        Docker & Kubernetes: Containerizes services and manages orchestration, scaling, and fault-tolerance.
        CI/CD Pipeline: Automates testing, deployment, and updates for each microservice.
        Nginx: Acts as a reverse proxy and SSL terminator for the entire system.

2. Detailed Component Architecture
Client-Side (Frontend)

The web app serves as the user interface for interacting with all real-time features:

    React.js/Vue.js: Provides dynamic and interactive user interfaces for chat, document editing, video/audio calls, etc.
    WebRTC: Handles peer-to-peer video/audio connections.
    WebSockets: Establishes bi-directional communication for real-time updates (chat, document edits).
    Canvas API (Fabric.js): Manages drawing in the real-time jam board.

Example workflow for video/audio meetings:

    A user starts or joins a call, and WebRTC negotiates connections using the WebSocket server as a signaling mechanism.
    Once the connection is established, the video/audio is streamed peer-to-peer directly between users.

WebSocket Server

This is the core real-time communication server. It handles:

    Real-Time Chat: Broadcasts messages between users in chat rooms.
    Collaborative Editing: Broadcasts document changes in real-time using CRDT or Operational Transformations (OT).
    Video/Audio Signaling: Manages WebRTC signaling, sending SDP offers and ICE candidates to establish peer-to-peer connections.

Technology: Flask-SocketIO (or Node.js with Socket.io if performance demands grow).
Collaboration Service

This service handles real-time collaboration features:

    Real-Time Text Editor: Integrates with the WebSocket server to synchronize document changes using ShareDB or Yjs.
    Jam Board: Listens to drawing events (e.g., lines, shapes) from users via WebSockets and broadcasts changes to all participants.

Synchronization Algorithm:

    Use OT (Operational Transformation) for text editing or CRDT (Conflict-Free Replicated Data Types) for real-time data consistency across distributed nodes.

Video/Audio Service

The service responsible for handling peer-to-peer connections for video/audio calls:

    WebRTC Signaling Server: Uses WebSockets to manage peer connections, ICE candidates, and session descriptions.
    TURN/STUN Servers: Required to establish connections between users who may be behind NAT or firewalls.

Technology: WebRTC + Flask-SocketIO for signaling.
Authentication Service

This service manages:

    OAuth2: Supports third-party login (Google, GitHub, etc.).
    Session Management: Issues JWT tokens for secure API access.
    User Profiles: Stores user-related metadata and access control.

Technology: Flask-JWT-Extended or OAuthLib for token-based authentication.
API Gateway

The API Gateway acts as the single point of entry for all client-side requests:

    Request Routing: Directs requests to the appropriate microservice (chat, collaboration, video/audio service).
    Rate Limiting: Protects the system from excessive requests.
    Security: Verifies JWT tokens and enforces authentication/authorization policies.

Technology: Kong or Traefik as an API Gateway.
Database Service

This service handles data storage:

    MongoDB: Stores user profiles, chat logs, document history, and session data. The schema-less structure allows for flexible data modeling.
    Redis: Manages pub/sub functionality for chat messages and signaling events. It also serves as a cache for frequently accessed data (user sessions, document states).
    File Storage: Store user-uploaded files in a distributed storage system like AWS S3 for scalability and cost-effectiveness.

Data Model:

    Users: Stores user profile information, credentials, and permissions.
    Documents: Stores real-time collaborative documents with version history.
    Sessions: Stores video/audio call session data, including metadata (start/end time, participants).

3. Infrastructure Overview
Load Balancer

    Balances incoming HTTP and WebSocket requests across multiple backend instances.
    Can use Nginx or HAProxy for load balancing both WebSockets and HTTP traffic.

Containerization (Docker)

    Docker: Containerizes all microservices (WebSocket server, collaboration service, video/audio service, API gateway).
    Kubernetes: Manages scaling, rolling updates, and fault tolerance for containers. It can scale each service independently based on traffic (e.g., scaling the WebSocket server when more users join).

CI/CD Pipeline

    GitHub Actions/Jenkins: Automates testing, building, and deployment of each microservice.
    Docker Registry: Stores and retrieves Docker images during deployment.
    Kubernetes Deployment: Each new version is deployed via rolling updates to ensure no downtime.

Monitoring and Logging

    Prometheus + Grafana: For real-time monitoring of system performance (CPU usage, memory, number of active users).
    ELK Stack (Elasticsearch, Logstash, Kibana): For logging, error tracking, and analyzing system logs across all services.

4. Security Considerations

    SSL/TLS: All client-server communications (WebSockets, REST APIs) are encrypted using HTTPS.
    JWT Authentication: Secure all API requests with token-based authentication.
    WebRTC Security: WebRTC connections are encrypted via DTLS and SRTP (which are built-in), but the signaling server should be secured.
    Rate Limiting: Enforce rate limits at the API Gateway level to prevent abuse.

5. Scaling and Performance

    Horizontally Scale WebSocket Servers: As traffic grows, spin up more WebSocket servers to handle concurrent connections, using Redis for pub/sub communication across instances.
    Database Scaling: Use MongoDB’s sharding to handle large-scale document storage. Redis can be distributed for caching and session management.
    Kubernetes Auto-Scaling: Kubernetes will automatically scale services based on resource usage (CPU, memory).

6. Example Workflow for Real-Time Collaboration

    User Authentication:
        A user logs in via OAuth2 or credentials.
        Flask backend issues a JWT token to the user.

    Real-Time Document Editing:
        The user opens a document.
        The collaboration service retrieves the document from MongoDB.
        Flask-SocketIO broadcasts any changes made by the user to other participants in real-time using OT or CRDT algorithms.

    Video/Audio Meeting:
        The user starts a call, and WebRTC initiates peer-to-peer connections.
        The signaling server (via WebSocket) facilitates connection negotiation between users.
        Media streams are exchanged directly between peers via WebRTC.

This architecture ensures modularity, scalability, and real-time capabilities while leveraging Flask for the backend and 
modern front-end technologies for a rich, interactive user experience. Let me know if you need more details on any specific 
part!


Personal Notes -- 

- Auth system ?? 
    - Auth0 
    - can replace the login system and can be impmented if needed

- The 3 types of video demand apps 
    - one to many (streeaming ) 
    - one to one (video call apps)
    - many to many ( group calls app )

WebRTC protocol is used for video conferencing apps like Zoom and Google Meet, and there are three network organization types for group calls in video conferencing systems,
which determine the quality and functionality of group calls.
Basically, WebRTC is a set of functions, available in most browsers, that allow computers to communicate directly,
feeding information in realtime without the need of a middleman. Great, this seems to be the solution to the video chat application! 


- The HTML5 canvas api 
    - for the canvas and drawing shapes and stuff 
    - how to track the mouse now ? 
        - https://www.geeksforgeeks.org/how-to-draw-with-mouse-in-html-5-canvas/   (this helps to draw and keep track)



---- Flow of the design and design essentials that are needed --------------

- Same page as the chat app 
    - input two names 
    - get a link
    - get the qr code 


- Join the page 
    - login the page 
        - input name 
    - option to join video and audio to start WebRTC
    - side bar for tab minimization and maximization
    - tab option for the board 
    - tab option for the code editor
    - tab option for the audio and video call 
        - option to close video 
        - option to close audio
        - option to join and rejoin audio


Edge case -- 

- what if the user goes offline for sending message and all other services 
    - 1. 
        - just disconnect the user completely and not allow the sync functions 
    - 2.
        - the sending message can be put in the queue for procesing and send one by one 
        - the audio and video will be cut off 
        - the drawing cursor will be stopped as well 
            - what id they draw on their side (synching issues)
        - A hybrid approach could work best:

            Queue Changes While Offline: Allow the offline user to continue making changes, but queue them for later synchronization when they come back online. This improves the user experience without major disruption.
            Show Online Status: Indicate in the UI when one user goes offline, so the online user knows that changes from their collaborator will be delayed.
            Conflict Resolution System: Use OT or CRDTs to manage conflicts, ensuring that changes are merged consistently when the offline user reconnects.



challenges -- 

- how to intergrate react in the build system ? 
- 

















Links - 
https://hackernoon.com/developing-a-video-conference-call-app-protocols-architecture-and-considerations
https://medium.com/@leonardo.daher/how-do-video-chat-applications-work-5d3fcd4155a1
