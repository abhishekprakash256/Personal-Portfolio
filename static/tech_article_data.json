

[
    {
        "article_name": "system-design",
        "aticle_data": [
            
            {"title": "System Design : a component overview", "image_src": "..\\static\\images\\tech\\system-design.png", "article_para": "As I embarked on the journey of mastering system design to excel in technical job interviews, I found myself immersed in the rich landscape of distributed systems. Combining resources from platforms like educative.io and literature such as System Design Interview An Insiderâ€™s Guide by Alex Xu, I began unraveling the intricacies of various components crucial to modern system architecture. The parallels I drew between theoretical knowledge and real-world systems were enlightening, offering a profound understanding that traditional university education had not provided.", "markdown_data": ""},
            {"title": "", "image_src": "", "article_para": "", "markdown_data": "**Load Balancer:** Vital for managing server requests,load balancers distribute incoming traffic among servers to prevent overloads. By monitoring server statuses and workload, they intelligently route requests to the least busy servers."},
            {"title": "", "image_src": "", "article_para": "", "markdown_data": "**Databases:** Serving as repositories for data, databases come in relational or non-relational forms, chosen based on specific use cases and accessibility needs. Replication algorithms ensure fault tolerance and data integrity."},
            {"title": "", "image_src": "", "article_para": "", "markdown_data": "**Content Delivery Network (CDN):** CDN accelerates content delivery by caching data closer to end-users, reducing latency. This geographically distributed network ensures efficient content delivery across diverse locations."},
            {"title": "", "image_src": "", "article_para": "", "markdown_data": "**Sequencer:** Responsible for assigning unique identifiers to data, sequencers utilize solutions like UUIDs or database-backed schemes to ensure data integrity and prevent conflicts."},
            {"title": "", "image_src": "", "article_para": "", "markdown_data": "**Distributed Monitoring System:** Essential for managing distributed systems, monitoring systems track component health and trigger alerts in case of anomalies, ensuring system reliability."},
            {"title": "", "image_src": "", "article_para": "", "markdown_data": "**Caching:** Caching systems store frequently accessed data to expedite retrieval, enhancing system performance. Data expiration policies ensure cache efficiency."},
            {"title": "", "image_src": "", "article_para": "", "markdown_data": "**Messaging Queue:** Messaging queues store data or jobs awaiting processing, facilitating efficient task management within the system."},
            {"title": "", "image_src": "", "article_para": "", "markdown_data": "**Pub-Sub System:** Enabling notification delivery across systems, pub-sub systems disseminate notifications to subscribers based on events. For instance, YouTube notifies subscribers of newly uploaded videos via channel subscriptions."},
            {"title": "", "image_src": "", "article_para": "", "markdown_data": "**Rate Limiter:** Positioned before servers, rate limiters regulate incoming requests, preventing server overload. Restrictions can be applied based on IP addresses or other identifiers."},
            {"title": "", "image_src": "", "article_para": "", "markdown_data": "**Distributed Search:** Distributed search systems enable efficient searching across vast datasets distributed across multiple nodes. They employ indexing and query distribution techniques to provide fast and scalable search capabilities. Examples include Elasticsearch and Apache Solr, which facilitate distributed indexing and querying of structured and unstructured data."},
            {"title": "", "image_src": "", "article_para": "", "markdown_data": "**Distributed Logging:** Distributed logging systems are used to collect, aggregate, and store log data generated by various components in a distributed system. These systems ensure centralized access to logs for monitoring, troubleshooting, and analysis purposes. Popular solutions like Apache Kafka and Fluentd enable scalable, real-time log collection and processing across distributed environments."},
            {"title": "", "image_src": "", "article_para": "", "markdown_data": "**Sharded Counters:** Sharded counters are used to maintain incrementing counters distributed across multiple nodes in a system. By partitioning the counter values across shards, these systems ensure scalability and high throughput for applications requiring fast and concurrent updates to counter values. Sharded counters are commonly employed in scenarios such as tracking user interactions, message processing, and distributed task management."}

            
           
            
    
        ],

        "card_one_text": "Image processing is a technique used by machines to understand data in a flat block of arrays, which can range from multi-dimensional arrays to few-dimensional arrays.",
        "image_url_card_one": "..\\static\\images\\tech\\image-processing.jpg",
        "card_one_url": "/tech/image-processing",
    
        "card_two_text": "Dynamic programming is a programming paradigm that can be used in problems which can be subdivided into smaller problems to get to the final solution. These sound like recursion but the difference comes in the storage of the values in each of the stages",
        "image_url_card_two": "..\\static\\images\\tech\\dynamic-programming.jpg",
        "card_two_url": "/tech/dynamic-programming",
    
        "card_three_text": "Static Academic website made to showcase the profile and works, made using HTML, CSS, Media Query (for the responsive optimization for mobile, tablet and different size devices). The website is consist of 8 pages that shows the",
        "image_url_card_three": "..\\static\\images\\projects\\academic-website\\main_page.png",
        "card_three_url": "/projects/academic-website",


        "first_social_media_url" : "",
        
        "second_social_media_url" : "",
        "button_link": "",
        "more_link":"/tech"
    
         }
        ,
    
        {
        "article_name": "dynamic-programming",
        "aticle_data": [
        {"title": "Dynamic Programming", "image_src": "..\\static\\images\\tech\\dynamic-programming.jpg", "article_para": "Dynamic programming is a programming paradigm that can be used in problems which can be subdivided into smaller problems to get to the final solution. These sound like recursion but the difference comes in the storage of the values in each of the stages of the subproblems to save the recomputation time of the same steps that have been already done.", "markdown_data": ""},
        {"title": "", "image_src": "", "article_para": "", "markdown_data": "The classic example that we can understand dynamic programming with is the Fibonacci series, which can be solved both recursively and using dynamic programming.\n ### Recursive Approach \n```python\ndef fibbo(nums):\n      if nums <= 1:\n        return 1\n      return fibbo(n-1) + fibbo(n-2)\n ```\n\n### Dynamic Programming with Memoization\n ```python\ndef fibonacci(n, memo={}):\n       if n in memo:\n         return memo[n]\n       if n <= 1:\n         return n\n       else:\n          memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)\n       return memo[n]\n ```\n\n### Dynamic Programming with Tabulation\n ```python\ndef fibonacci(n):\n        if n <= 1:\n            return n\n   \n        fib_table = [0] * (n + 1)\n        fib_table[1] = 1\n\n        for i in range(2, n + 1):\n           fib_table[i] = fib_table[i - 1] + fib_table[i - 2]\n\n        return fib_table[n]\n"},
        {"title": "", "image_src": "", "article_para": "", "markdown_data": "### The above code has shown 3 ways to solve the same problem:\n1. The first one is the recursive approach where the problem is divided into smaller subproblems and the results are calculated in the form of a tree.\n2. The second is dynamic programming with memoization, where memoization is used for the intermediate steps.\n3. The tabulation approach is a bottom-up approach where subproblems are stored in an array structure for later usage.\n### Problem Pattern for Dynamic Programming\n- Is the problem can be divided into smaller sub-overlapping subproblems and the final result is based on them."},

        {"title": "", "image_src": "", "article_para": "", "markdown_data": "### Classic Problems with Dynamic Programming\n#### The House Robber Problem\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, but adjacent houses have security systems connected. Given an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\n#### Algorithm\n1. **Initialization**:\n - Initialize a list `dp` of size `amount + 1` to store the fewest number of coins needed to make up each amount from 0 to amount. Set all values in d to amount + 1, which is effectively infinity, except for `dp[0]` which is set to 0 since zero coins are needed to make up an amount of 0.\n2. **Dynamic Programming Iteration**:\n - Iterate over each amount `a` from 1 to `amount`.\n- For each amount `a`, iterate over each coin denomination `c` in the list of `coins`.\n- If the current amount `a` minus the current coin denomination `c` is greater than or equal to 0:\n- Update `dp[a]` to the minimum of its current value and `1 + dp[a - c]`, representing the number of coins needed to make up the amount `a` using the current coin `c`, plus the fewest number of coins needed to make up the remaining amount `(a - c)` using any combination of coins available.\n3. **Return Result**:\n - Return `dp[amount]`, which represents the fewest number of coins needed to make up the original amount `amount`.\n- If `dp[amount]` is equal to `amount + 1`, return -1.\n#### Python Implementation\n```python\nclass  Solution():\n        def coinChange(self, coins):\n          dp = [amount + 1] * (amount + 1)\n          dp[0] = 0\n             for a in range(1, amount + 1):\n                for c in coins:\n                   if a - c >= 0:\n                        dp[a] = min(dp[a], 1 + dp[a - c])\n         return dp[amount] if dp[amount] != amount + 1 else -1\n```"},
        {"title": "", "image_src": "", "article_para": "", "markdown_data": "### The Coin Change Problem\nYou are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money. Return the fewest number of coins that you need to make up that amount.\n\n#### Algorithm\n1. **Initialization**:\n   - Initialize a list `dp` of size `amount + 1` to store the fewest number of coins needed to make up each amount from 0 to `amount`. Set all values in `dp` to `amount + 1`, which is effectively infinity, except for `dp[0]` which is set to 0 since zero coins are needed to make up an amount of 0.\n2. **Dynamic Programming Iteration**:\n   - Iterate over each amount `a` from 1 to `amount`.\n   - For each amount `a`, iterate over each coin denomination `c` in the list of `coins`.\n   - If the current amount `a` minus the current coin denomination `c` is greater than or equal to 0:\n     - Update `dp[a]` to the minimum of its current value and `1 + dp[a - c]`, representing the number of coins needed to make up the amount `a` using the current coin `c`, plus the fewest number of coins needed to make up the remaining amount `(a - c)` using any combination of coins available.\n3. **Return Result**:\n   - Return `dp[amount]`, which represents the fewest number of coins needed to make up the original amount `amount`.\n   - If `dp[amount]` is equal to `amount + 1`, return -1.\n\n#### Python Implementation\n```python\nclass Solution():\n    def coinChange(self, coins):\n        dp = [amount + 1] * (amount + 1)\n        dp[0] = 0\n        for a in range(1, amount + 1):\n            for c in coins:\n                if a - c >= 0:\n                    dp[a] = min(dp[a], 1 + dp[a - c])\n        return dp[amount] if dp[amount] != amount + 1 else -1\n```"}
                
    
        ],

        "card_one_text": "Image processing is a technique used by machines to understand data in a flat block of arrays, which can range from multi-dimensional arrays to few-dimensional arrays.",
        "image_url_card_one": "..\\static\\images\\tech\\image-processing.jpg",
        "card_one_url": "/tech/image-processing",
    
        "card_two_text": "As I embarked on the journey of mastering system design to excel in technical job interviews, I found myself immersed in the rich landscape of distributed systems. Combining resources from platforms like educative.io and literature such as ",
        "image_url_card_two": "..\\static\\images\\tech\\system-design.png",
        "card_two_url": "/tech/system-design",
    
        "card_three_text": "Static Academic website made to showcase the profile and works, made using HTML, CSS, Media Query (for the responsive optimization for mobile, tablet and different size devices). The website is consist of 8 pages that shows the",
        "image_url_card_three": "..\\static\\images\\projects\\academic-website\\main_page.png",
        "card_three_url": "/projects/academic-website",


        "first_social_media_url" : "",
        
        "second_social_media_url" : "",
        "button_link": "",
        "more_link":"/tech"
    
         },

    {
        "article_name": "image-processing",
        "aticle_data": [
            
        
            {"title": "Image Processsing", "image_src": "..\\static\\images\\tech\\image-processing.jpg", "article_para": "Image processing is a technique used by machines to understand data in a flat block of arrays, which can range from multi-dimensional arrays to few-dimensional arrays.", "markdown_data": "Let's delve into the basics of image processing. Computers lack the ability to see the world as humans do. Thus, we employ techniques to enable computers to perceive the world in their own language, primarily consisting of numbers. To a computer, an image is essentially a combination of numbers arranged to form a pattern. Colors are represented as numbers in overlapping arrays.\n\nA fundamental example is the black and white image, constructed by basic building blocks called pixels, analogous to cells in our bodies. Pixel color variation gives an image its color. In a black and white image, the range of pixel color is from 0 to 255, where 0 represents pure black and 255 represents pure white. There are shades between these extremes, ranging from lighter to darker shades. Pixels are stored in a matrix, which can be two-dimensional or n-dimensional depending on the color spectrum of the image. Computers read this array and extract image information based on the assigned pixel number.\n\nIn a black and white image, a 5x5 array with each pixel's value as 255 indicates a white image; conversely, if the pixels are 0, it represents a black image. The scenario changes when dealing with color images, where machines create colors using a mixture of three primary colors: red, blue, and green. The shades of red, blue, and green can be adjusted as the image's color varies.\n\nColor images are represented as a combination of 3-dimensional arrays, with each array representing red, blue, and green shades. The values range from 0 to 255, allowing for a total of 256 shades. Therefore, for each pixel in an RGB image:\n\n- The red component can vary from 0 (no red) to 255 (maximum red).\n- The green component can vary from 0 (no green) to 255 (maximum green).\n- The blue component can vary from 0 (no blue) to 255 (maximum blue).\n\nCombining these three color components in different proportions produces a wide range of colors. For example, pure red would have an RGB value of (255, 0, 0), pure green would have an RGB value of (0, 255, 0), and pure blue would have an RGB value of (0, 0, 255). White is represented as (255, 255, 255), and black is represented as (0, 0, 0).\n\nAs images are stored in computer systems, we can manipulate the numbers to manipulate the image. Thus, we can enhance images by adjusting brightness, contrast, enlarging them, and more."},
            
            {"title": "", "image_src": "", "article_para": "", "markdown_data": "### Applications of Image Processing\n\n1. **Image Filtering**: Enhances or modifies images through operations like blurring, sharpening, edge detection, and noise reduction.\n2. **Image Enhancement**: Improves visual quality by adjusting brightness, contrast, histogram equalization, etc.\n3. **Image Segmentation**: Divides images into meaningful regions or objects for tasks like object detection and medical image analysis.\n4. **Feature Extraction**: Identifies and extracts relevant information or features from images.\n5. **Object Detection and Recognition**: Locates and identifies objects within images using techniques ranging from traditional methods to deep learning.\n6. **Image Classification**: Assigns labels or categories to images based on their content.\n7. **Image Restoration**: Recovers original images from degraded versions, removing noise, blurring, etc.\n8. **Medical Image Processing**: Analyzes images from medical imaging modalities for diagnosis and treatment planning.\n9. **Remote Sensing and Satellite Image Processing**: Analyzes aerial or satellite imagery for tasks like land cover classification and environmental assessment.\n10. **Geometric Image Transformation**: Applies operations like rotation, scaling, and warping for image alignment and correction.\n11. **Image Compression**: Reduces storage size or transmission bandwidth while preserving image quality.\n\nThese applications illustrate the diverse range of topics within image processing, which intersects with computer vision, signal processing, machine learning, and various industries such as healthcare, agriculture, and entertainment."}
 
            
    
        ],

        "card_one_text": "As I embarked on the journey of mastering system design to excel in technical job interviews, I found myself immersed in the rich landscape of distributed systems. Combining resources from platforms like educative.io and literature such as ",
        "image_url_card_one": "..\\static\\images\\tech\\system-design.png",
        "card_one_url": "/tech/system-design",
    
        "card_two_text": "Dynamic programming is a programming paradigm that can be used in problems which can be subdivided into smaller problems to get to the final solution. These sound like recursion but the difference comes in the storage of the values in each of the stages",
        "image_url_card_two": "..\\static\\images\\tech\\dynamic-programming.jpg",
        "card_two_url": "/tech/dynamic-programming",
    
        "card_three_text": "Static Academic website made to showcase the profile and works, made using HTML, CSS, Media Query (for the responsive optimization for mobile, tablet and different size devices). The website is consist of 8 pages that shows the",
        "image_url_card_three": "..\\static\\images\\projects\\academic-website\\main_page.png",
        "card_three_url": "/projects/academic-website",



        "first_social_media_url" : "",
        
        "second_social_media_url" : "",
        "button_link": "",
        "more_link":"/tech"
    
         }

    
    ]
    
